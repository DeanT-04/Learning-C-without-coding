# Lesson 03: Advanced File Handling

## Overview

This lesson covers advanced file handling techniques in C, including binary file operations, file positioning, error handling, buffering control, and practical file processing scenarios. These techniques are essential for building robust applications that work with files efficiently and reliably.

## Key Concepts

### Binary vs Text Files
- **Text Files**: Human-readable, platform-dependent line endings
- **Binary Files**: Raw data storage, platform-independent, more efficient
- **Usage**: Binary for structured data, text for human-readable content

### File Positioning
- **Sequential Access**: Reading/writing from current position
- **Random Access**: Jump to any position in the file
- **Seeking**: Moving the file pointer to specific locations

### Error Handling
- **Error Detection**: Using return values and error flags
- **Error Recovery**: Clearing errors and continuing operation
- **Robust Programming**: Handling all possible failure scenarios

## Code Examples Explained

### 1. Binary File Operations

```c
FILE *bin_file = fopen("data.dat", "wb");
fwrite(&data, sizeof(struct Record), 1, bin_file);
```

**Key Points:**
- Use "rb" and "wb" modes for binary files
- `fwrite()` and `fread()` for binary data
- Store data exactly as it appears in memory
- More efficient than text format for structured data

**Advantages of Binary Files:**
- Faster read/write operations
- Smaller file sizes
- Exact data representation
- No conversion overhead

### 2. File Positioning and Seeking

```c
fseek(file, offset, whence);
long position = ftell(file);
rewind(file);
```

**Seek Origins:**
- `SEEK_SET`: From beginning of file
- `SEEK_CUR`: From current position
- `SEEK_END`: From end of file

**Use Cases:**
- Random access to records
- File size determination
- Implementing file-based databases
- Reading file headers and footers

### 3. Advanced File Operations

```c
FILE *temp = tmpfile();  // Temporary file
rename("old.txt", "new.txt");  // Rename file
remove("file.txt");  // Delete file
```

**Temporary Files:**
- Automatically deleted when closed
- Unique names generated by system
- Useful for intermediate processing

### 4. Error Handling

```c
if (file == NULL) {
    printf("Error: %s\n", strerror(errno));
    return -1;
}

if (ferror(file)) {
    clearerr(file);
}
```

**Error Detection Methods:**
- Check return values (NULL, EOF, etc.)
- Use `ferror()` to detect I/O errors
- Use `feof()` to detect end-of-file
- Use `errno` and `strerror()` for error messages

### 5. File Buffering Control

```c
setvbuf(file, buffer, mode, size);
```

**Buffering Modes:**
- `_IOFBF`: Full buffering (default for files)
- `_IOLBF`: Line buffering (flush on newline)
- `_IONBF`: No buffering (immediate I/O)

**Performance Considerations:**
- Full buffering: Best for large file operations
- Line buffering: Good for interactive applications
- No buffering: Use for critical data that must be written immediately

### 6. File Copying Techniques

**Character-by-Character:**
```c
while ((ch = fgetc(source)) != EOF) {
    fputc(ch, dest);
}
```

**Line-by-Line:**
```c
while (fgets(buffer, sizeof(buffer), source) != NULL) {
    fputs(buffer, dest);
}
```

**Block Copy (Most Efficient):**
```c
while ((bytes = fread(buffer, 1, sizeof(buffer), source)) > 0) {
    fwrite(buffer, 1, bytes, dest);
}
```

### 7. CSV File Processing

```c
char *token = strtok(line, ",");
while (token != NULL) {
    // Process each field
    token = strtok(NULL, ",");
}
```

**CSV Parsing Considerations:**
- Handle quoted fields containing commas
- Trim whitespace from fields
- Validate data types and ranges
- Handle escape characters and special cases

## Best Practices

### 1. Always Check Return Values
```c
FILE *file = fopen("data.txt", "r");
if (file == NULL) {
    fprintf(stderr, "Cannot open file: %s\n", strerror(errno));
    return -1;
}
```

### 2. Use Appropriate File Modes
- "r", "w", "a" for text files
- "rb", "wb", "ab" for binary files
- "r+", "w+", "a+" for read/write access

### 3. Handle Errors Gracefully
```c
if (fwrite(data, size, count, file) != count) {
    if (ferror(file)) {
        fprintf(stderr, "Write error occurred\n");
        clearerr(file);
    }
}
```

### 4. Close Files Properly
```c
if (file != NULL) {
    fclose(file);
    file = NULL;
}
```

### 5. Use Binary Mode for Structured Data
- Faster than text format
- Preserves exact data representation
- Platform-independent (with proper design)

## Common Pitfalls

1. **Text vs Binary Mode**: Using wrong mode can corrupt data
2. **Buffer Overflows**: Not checking buffer sizes in `fgets()`
3. **Unchecked Return Values**: Ignoring error conditions
4. **File Handle Leaks**: Not closing files properly
5. **Platform Dependencies**: Assuming specific line endings
6. **Concurrent Access**: Multiple processes accessing same file

## Performance Optimization

### 1. Choose Appropriate Buffer Sizes
```c
setvbuf(file, NULL, _IOFBF, 8192);  // 8KB buffer
```

### 2. Use Block I/O for Large Files
```c
char buffer[4096];
while ((bytes = fread(buffer, 1, sizeof(buffer), file)) > 0) {
    // Process buffer
}
```

### 3. Minimize Seek Operations
- Read/write in sequential order when possible
- Batch operations to reduce system calls
- Use memory mapping for very large files (platform-specific)

## File Format Design

### Binary File Structure
```c
struct FileHeader {
    char magic[4];      // File type identifier
    int version;        // Format version
    int record_count;   // Number of records
    int record_size;    // Size of each record
};
```

### Error Recovery Strategies
- Write checksums for data integrity
- Use transaction-like operations
- Implement backup and rollback mechanisms
- Validate file format before processing

## Compilation and Execution

```bash
make          # Compile the program
make run      # Compile and run
make clean    # Remove compiled files
make debug    # Compile with debugging symbols
```

## Expected Output

The program demonstrates:
- Binary file creation and reading
- File positioning and seeking operations
- Advanced file operations (temp files, rename, delete)
- Comprehensive error handling
- Buffer control and performance optimization
- File copying with different methods
- CSV file processing and parsing

## Security Considerations

### 1. Path Validation
```c
// Validate file paths to prevent directory traversal
if (strstr(filename, "..") != NULL) {
    fprintf(stderr, "Invalid file path\n");
    return -1;
}
```

### 2. File Permissions
- Use appropriate file permissions
- Check file access before operations
- Handle permission denied errors gracefully

### 3. Resource Limits
- Limit file sizes to prevent disk exhaustion
- Implement timeouts for file operations
- Monitor and limit concurrent file handles

## Next Steps

After mastering advanced file handling, you'll be ready to:
- Learn data structures implementation (Lesson 04)
- Work with function pointers and callbacks
- Build multi-file projects with complex I/O
- Implement file-based databases and indexing systems

## Key Takeaways

- Binary files are more efficient for structured data than text files
- Always implement comprehensive error handling for file operations
- Use appropriate buffering strategies for optimal performance
- File positioning enables random access and efficient data manipulation
- Proper resource management prevents file handle leaks and corruption
- Consider security implications when working with user-provided file paths